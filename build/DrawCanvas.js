"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _react=_interopRequireDefault(require("react")),_propTypes=_interopRequireDefault(require("prop-types")),_line=_interopRequireDefault(require("./handlers/line")),_polygon=_interopRequireDefault(require("./handlers/polygon")),_rectangle=_interopRequireDefault(require("./handlers/rectangle")),_canvasHandler=_interopRequireDefault(require("./handlers/canvasHandler")),_history=_interopRequireDefault(require("./handlers/history"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}function _typeof(a){return _typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(a){return typeof a}:function(a){return a&&"function"==typeof Symbol&&a.constructor===Symbol&&a!==Symbol.prototype?"symbol":typeof a},_typeof(a)}function _toConsumableArray(a){return _arrayWithoutHoles(a)||_iterableToArray(a)||_nonIterableSpread()}function _nonIterableSpread(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function _iterableToArray(a){if(Symbol.iterator in Object(a)||"[object Arguments]"===Object.prototype.toString.call(a))return Array.from(a)}function _arrayWithoutHoles(a){if(Array.isArray(a)){for(var b=0,c=Array(a.length);b<a.length;b++)c[b]=a[b];return c}}function _objectSpread(a){for(var b=1;b<arguments.length;b++){var c=null==arguments[b]?{}:arguments[b],d=Object.keys(c);"function"==typeof Object.getOwnPropertySymbols&&(d=d.concat(Object.getOwnPropertySymbols(c).filter(function(a){return Object.getOwnPropertyDescriptor(c,a).enumerable}))),d.forEach(function(b){_defineProperty(a,b,c[b])})}return a}function _classCallCheck(a,b){if(!(a instanceof b))throw new TypeError("Cannot call a class as a function")}function _defineProperties(a,b){for(var c,d=0;d<b.length;d++)c=b[d],c.enumerable=c.enumerable||!1,c.configurable=!0,"value"in c&&(c.writable=!0),Object.defineProperty(a,c.key,c)}function _createClass(a,b,c){return b&&_defineProperties(a.prototype,b),c&&_defineProperties(a,c),a}function _possibleConstructorReturn(a,b){return b&&("object"===_typeof(b)||"function"==typeof b)?b:_assertThisInitialized(a)}function _getPrototypeOf(a){return _getPrototypeOf=Object.setPrototypeOf?Object.getPrototypeOf:function(a){return a.__proto__||Object.getPrototypeOf(a)},_getPrototypeOf(a)}function _inherits(a,b){if("function"!=typeof b&&null!==b)throw new TypeError("Super expression must either be null or a function");a.prototype=Object.create(b&&b.prototype,{constructor:{value:a,writable:!0,configurable:!0}}),b&&_setPrototypeOf(a,b)}function _setPrototypeOf(a,b){return _setPrototypeOf=Object.setPrototypeOf||function(a,b){return a.__proto__=b,a},_setPrototypeOf(a,b)}function _assertThisInitialized(a){if(void 0===a)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return a}function _defineProperty(a,b,c){return b in a?Object.defineProperty(a,b,{value:c,enumerable:!0,configurable:!0,writable:!0}):a[b]=c,a}var tools={Line:_line.default,Polygon:_polygon.default,Rectangle:_rectangle.default},INITIAL_STATE={Line:[]/**
 * @componentName DrawCanvas
 * @description: This is a component to draw
 * shapes on canvas
 */},DrawCanvas=/*#__PURE__*/function(a){function b(){var a,c;_classCallCheck(this,b);for(var d=arguments.length,e=Array(d),f=0;f<d;f++)e[f]=arguments[f];return c=_possibleConstructorReturn(this,(a=_getPrototypeOf(b)).call.apply(a,[this].concat(e))),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"state",{undoData:[],redoData:[],data:INITIAL_STATE,canvasData:[],polygonId:_canvasHandler.default.uuid(),rectangleId:_canvasHandler.default.uuid()}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"onMouseDown",function(a){if(c.tool){var b=c.props,d=b.brushSize,e=b.color,f=c.props.tool,g=c.state,h=g.polygonId,i=g.rectangleId;"Line"!==f&&c.createNewToolInitialData(f);var j="Line"===f?"Line":"Polygon"===f?"Polygon_".concat(h):"Rectangle_".concat(i);c.setState({currentKey:j}),c.tool.onMouseDown(c.getCursorPosition(a),{brushSize:d,color:e,tool:f})}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"createNewToolInitialData",function(a){var b=a.startsWith("Poly")?"polygonId":"rectangleId",d="".concat(a,"_").concat(c.state[b]);c.state.data[d]||c.setState({data:_objectSpread({},c.state.data,_defineProperty({},d,[]))})}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"onMouseMove",function(a){c.tool&&c.tool.onMouseMove(c.getCursorPosition(a),function(){c.setState({polygonId:_canvasHandler.default.uuid(),currentKey:null}),c.tool=null,c.props.onFinishDraw&&c.props.onFinishDraw()})}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"onMouseUp",function(a){if(c.tool){var b=c.tool.onMouseUp(c.getCursorPosition(a),function(){c.setState({rectangleId:_canvasHandler.default.uuid(),currentKey:null}),c.tool=null,c.props.onFinishDraw&&c.props.onFinishDraw()});c.updateData(b)}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"updateData",function(a){var b=c.state,d=b.polygonId,e=b.rectangleId,f=c.props.tool,g="Line"===f?"Line":"Polygon"===f?"Polygon_".concat(d):"Rectangle_".concat(e);// TODO: Refactor, this code to a DRY version
if(a){var h=g.startsWith("Poly")||g.startsWith("Line")?[].concat(_toConsumableArray(c.state.data[g]),[a.data]):[].concat(_toConsumableArray(c.state.data[g]),_toConsumableArray(a.data));c.setState({undoData:[].concat(_toConsumableArray(c.state.undoData),[c.state.data]),data:_objectSpread({},c.state.data,_defineProperty({},g,h)),canvasData:[].concat(_toConsumableArray(c.state.canvasData),[a.canvas])},function(){c.props.onDataUpdate&&c.props.onDataUpdate(c.state.data)})}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"getCursorPosition",function(a){var b=Math.round,d=c.canvas.getBoundingClientRect(),e=d.top,f=d.left;// clientY and clientX coordinate inside the element that the event occur.
return{x:b(a.clientX-f),y:b(a.clientY-e)}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"cleanCanvas",function(){c.ctx.clearRect(0,0,c.canvas.width,c.canvas.height),c.setState({data:INITIAL_STATE,canvasData:[]},function(){c.props.onDataUpdate&&c.props.onDataUpdate(c.state.data)})}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"isCtrlPressed",function(a){return a.ctrlKey||a.metaKey}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"isShiftPressed",function(a){return a.shiftKey}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"onKeyDown",function(a){var b=c.isCtrlPressed(a),d=c.isShiftPressed(a),e=90;// TODO: treat the case where polygon is less than 3 points
// we must not render it, but neither redo should have its last state
if(b&&a.which===e){var f=c.state.undoData,g=_history.default.filterPolygon(f.pop());c.loadDraw(g,!0),c.setState({data:g,undoData:f,redoData:[].concat(_toConsumableArray(c.state.redoData),[c.state.data])})}if(b&&d&&a.which===e){var h=c.state.redoData,i=h.pop();c.loadDraw(i,!0),c.setState({data:i})}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"onKeyUp",function(a){if("Escape"===a.key&&c.state.currentKey)// undo current drawing
{var b=_history.default.cancel(c.state.currentKey,c.state.data);c.setState({data:b,currentKey:null},function(){c.loadDraw(c.state.data,!0),c.props.onDataUpdate(c.state.data),c.tool=null})}}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"forceLoadDraw",function(a){c.loadDraw(a)}),_defineProperty(_assertThisInitialized(_assertThisInitialized(c)),"loadDraw",function(a,b){var d=0,e=1,f=2;c.ctx.clearRect(0,0,c.canvas.width,c.canvas.height),a&&Object.keys(a).forEach(function(b){var g=_canvasHandler.default.getTool(b);c.tool=tools[g],c.tool.ctx=c.ctx;// avoid mutate initial data;
var h={};if(b.startsWith("Rectan")){var j=a[b][f]?f:1;h[b]=[a[b][0],a[b][j]]}var i=b.startsWith("Rectan")?h[b]:a[b];b.startsWith("Line")||b.startsWith("Arrang")?i.forEach(function(a){c.tool.draw({x:a[d][0],y:a[d][1]},{x:a[e][0],y:a[e][1]},!1,{options:{brushSize:c.props.brushSize}})}):(i.forEach(function(a,d,e){var f=b.startsWith("Rect")?e[d+1]:e[d+1]||e[0];f&&c.tool.draw({x:a[0],y:a[1]},{x:f[0],y:f[1]},!1,{options:{brushSize:c.props.brushSize}})}),b.startsWith("Poly")&&c.tool.fillGeometry(i))}),c.tool&&c.tool.resetState(),c.tool=null,c.props.onFinishDraw&&c.props.onFinishDraw(),b||c.setState({data:_objectSpread({},c.state.data,a)},function(){return c.props.onDataUpdate(c.state.data)})}),c}return _inherits(b,a),_createClass(b,[{key:"componentDidMount",value:function a(){this.ctx=this.canvas.getContext("2d"),this.props.initialData&&this.props.imgSrc&&this.loadDraw(this.props.initialData)}},{key:"componentDidUpdate",value:function b(a){a.tool!==this.props.tool&&this.props.tool&&(this.tool=tools[this.props.tool],this.tool.ctx=this.ctx,this.tool.resetState()),a.imgSrc!==this.props.imgSrc&&this.loadDraw(this.props.initialData)}},{key:"render",value:function f(){var a=this,b=this.props,c=b.width,d=b.height,e=b.imgSrc;return _react.default.createElement(_react.default.Fragment,null,_react.default.createElement("canvas",{tabIndex:"1",ref:function c(b){return a.canvas=b},width:c,height:d,style:{color:"black",backgroundImage:"url(".concat(e,")"),backgroundSize:"cover"},onMouseDown:this.onMouseDown,onMouseMove:this.onMouseMove,onMouseUp:this.onMouseUp,onKeyDown:this.onKeyDown,onKeyUp:this.onKeyUp}))}}]),b}(_react.default.PureComponent);DrawCanvas.propTypes={/**
     * The width of canvas
     */width:_propTypes.default.number,/**
     * the height of the canvas
     */height:_propTypes.default.number,/**
     * Background image to canvas;
     */imgSrc:_propTypes.default.string,/**
     * BrushSize to draw
     */brushSize:_propTypes.default.number,/**
     * Color of what we want draw
     */color:_propTypes.default.string,/**
     * CanUndo
     */canUndo:_propTypes.default.bool,/**
     * Shapes that you can select to draw
     */tool:_propTypes.default.oneOf(["Line","Polygon","Rectangle"]),/**
     * Is the data to be be draw when load the component
     */initialData:_propTypes.default.object,/**
     * This is a callback function that we be called
     * everytime the data updates
     */onDataUpdate:_propTypes.default.func,/**
     * This is a callback function what we be triggered
     * when the shape is drawn
     */onFinishDraw:_propTypes.default.func},DrawCanvas.defaultProps={width:300,height:300,brushSize:2,color:"#ff0000",canUndo:!1};var _default=DrawCanvas;exports.default=_default;